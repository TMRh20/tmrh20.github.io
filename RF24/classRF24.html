<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Optimized High Speed NRF24L01+ Driver Class Documenation: RF24 Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Optimized High Speed NRF24L01+ Driver Class Documenation
   </div>
   <div id="projectbrief">TMRh20 2014 - Optimized Fork of NRF24L01+ Driver</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="classRF24-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">RF24 Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="RF24_8h_source.html">RF24.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Primary public interface</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These are the main methods you need to operate the chip </p>
</div></td></tr>
<tr class="memitem:a8cd165a822c8f77e10782c6729c5b088"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a8cd165a822c8f77e10782c6729c5b088">RF24</a> (uint8_t _cepin, uint8_t _cspin)</td></tr>
<tr class="separator:a8cd165a822c8f77e10782c6729c5b088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e720d303ad594de611a813c69244517"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a9e720d303ad594de611a813c69244517">begin</a> (void)</td></tr>
<tr class="separator:a9e720d303ad594de611a813c69244517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30a2733a3889bdc331fe2d2f4f0f7b39"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a30a2733a3889bdc331fe2d2f4f0f7b39">startListening</a> (void)</td></tr>
<tr class="separator:a30a2733a3889bdc331fe2d2f4f0f7b39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f144d73fc447c8ac2d1a4166210fd88"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a6f144d73fc447c8ac2d1a4166210fd88">stopListening</a> (void)</td></tr>
<tr class="separator:a6f144d73fc447c8ac2d1a4166210fd88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a127105eb7a3b351cfe777c1cec50627a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a127105eb7a3b351cfe777c1cec50627a">available</a> (void)</td></tr>
<tr class="separator:a127105eb7a3b351cfe777c1cec50627a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e2eacacfba96426c192066f04054c5b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a8e2eacacfba96426c192066f04054c5b">read</a> (void *buf, uint8_t len)</td></tr>
<tr class="separator:a8e2eacacfba96426c192066f04054c5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cd4c198a47704db20b6b5cf0731cd58"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a4cd4c198a47704db20b6b5cf0731cd58">write</a> (const void *buf, uint8_t len)</td></tr>
<tr class="separator:a4cd4c198a47704db20b6b5cf0731cd58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2e409e62d49a23e372a70b904ae30e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#af2e409e62d49a23e372a70b904ae30e1">openWritingPipe</a> (const uint8_t *address)</td></tr>
<tr class="separator:af2e409e62d49a23e372a70b904ae30e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9edc910ccc1ffcff56814b08faca5535"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a9edc910ccc1ffcff56814b08faca5535">openReadingPipe</a> (uint8_t number, const uint8_t *address)</td></tr>
<tr class="separator:a9edc910ccc1ffcff56814b08faca5535"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Advanced Operation</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Methods you can use to drive the chip in more advanced ways </p>
</div></td></tr>
<tr class="memitem:adc95213ed4c8569a90eb33122e16cea6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#adc95213ed4c8569a90eb33122e16cea6">printDetails</a> (void)</td></tr>
<tr class="separator:adc95213ed4c8569a90eb33122e16cea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace7dd139fabc16b77cb8325faa07620f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#ace7dd139fabc16b77cb8325faa07620f">available</a> (uint8_t *pipe_num)</td></tr>
<tr class="separator:ace7dd139fabc16b77cb8325faa07620f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0a51923a09ba4f3478aba9be0f8a6a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#aa0a51923a09ba4f3478aba9be0f8a6a1">powerDown</a> (void)</td></tr>
<tr class="separator:aa0a51923a09ba4f3478aba9be0f8a6a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cdaf47aa0edd6dca1b9a8bb7972a1a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a5cdaf47aa0edd6dca1b9a8bb7972a1a3">powerUp</a> (void)</td></tr>
<tr class="separator:a5cdaf47aa0edd6dca1b9a8bb7972a1a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23bfe6502d74bb5bbccb3a7f2ba2b5ea"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a23bfe6502d74bb5bbccb3a7f2ba2b5ea">write</a> (const void *buf, uint8_t len, const bool multicast)</td></tr>
<tr class="separator:a23bfe6502d74bb5bbccb3a7f2ba2b5ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47b2516993481b58e724d1274a7fd9cb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a47b2516993481b58e724d1274a7fd9cb">writeFast</a> (const void *buf, uint8_t len)</td></tr>
<tr class="separator:a47b2516993481b58e724d1274a7fd9cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad16d53de0327c0b41d170cbda4bf41af"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#ad16d53de0327c0b41d170cbda4bf41af">writeFast</a> (const void *buf, uint8_t len, const bool multicast)</td></tr>
<tr class="separator:ad16d53de0327c0b41d170cbda4bf41af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6fd8d5ee490d54ae1cb2e8fefee535f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#ae6fd8d5ee490d54ae1cb2e8fefee535f">writeBlocking</a> (const void *buf, uint8_t len, uint32_t timeout)</td></tr>
<tr class="separator:ae6fd8d5ee490d54ae1cb2e8fefee535f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12cc453453c94969d4d3f0edb3778c83"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a12cc453453c94969d4d3f0edb3778c83">txStandBy</a> ()</td></tr>
<tr class="separator:a12cc453453c94969d4d3f0edb3778c83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6f36353c1bdfbaf3c530d118cb84baa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#aa6f36353c1bdfbaf3c530d118cb84baa">txStandBy</a> (uint32_t timeout)</td></tr>
<tr class="separator:aa6f36353c1bdfbaf3c530d118cb84baa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65619238c25036c3de72dc2c1a1c6e52"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a65619238c25036c3de72dc2c1a1c6e52">writeAckPayload</a> (uint8_t pipe, const void *buf, uint8_t len)</td></tr>
<tr class="separator:a65619238c25036c3de72dc2c1a1c6e52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6253607ac2a1995af91a35cea6899c31"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a6253607ac2a1995af91a35cea6899c31">enableDynamicAck</a> ()</td></tr>
<tr class="separator:a6253607ac2a1995af91a35cea6899c31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30c2736fd0df9c8128cef408c8b88e92"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a30c2736fd0df9c8128cef408c8b88e92">isAckPayloadAvailable</a> (void)</td></tr>
<tr class="separator:a30c2736fd0df9c8128cef408c8b88e92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb97dc4bdf4d2d84ea44060ac5b4ed89"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#afb97dc4bdf4d2d84ea44060ac5b4ed89">whatHappened</a> (bool &amp;tx_ok, bool &amp;tx_fail, bool &amp;rx_ready)</td></tr>
<tr class="separator:afb97dc4bdf4d2d84ea44060ac5b4ed89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f27a53cda5f707c817c9a89a8425489"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a7f27a53cda5f707c817c9a89a8425489">startFastWrite</a> (const void *buf, uint8_t len, const bool multicast)</td></tr>
<tr class="separator:a7f27a53cda5f707c817c9a89a8425489"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa27519fc289920094422033e0bbf8cf9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#aa27519fc289920094422033e0bbf8cf9">startWrite</a> (const void *buf, uint8_t len, const bool multicast)</td></tr>
<tr class="separator:aa27519fc289920094422033e0bbf8cf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaf7fa54d3ab2a85ce215b4bf6ae933b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#aeaf7fa54d3ab2a85ce215b4bf6ae933b">reUseTX</a> ()</td></tr>
<tr class="separator:aeaf7fa54d3ab2a85ce215b4bf6ae933b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb7915b1d2661a82137573344f659e81"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#adb7915b1d2661a82137573344f659e81">flush_tx</a> (void)</td></tr>
<tr class="separator:adb7915b1d2661a82137573344f659e81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0d522ccf39493510e64bf1740be790d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#ad0d522ccf39493510e64bf1740be790d">testCarrier</a> (void)</td></tr>
<tr class="separator:ad0d522ccf39493510e64bf1740be790d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a821285f3b54553f4402eb3fd0ac6d6c1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a821285f3b54553f4402eb3fd0ac6d6c1">testRPD</a> (void)</td></tr>
<tr class="separator:a821285f3b54553f4402eb3fd0ac6d6c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35e5f1533b7753806c42b76e782d917e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a35e5f1533b7753806c42b76e782d917e">isValid</a> ()</td></tr>
<tr class="separator:a35e5f1533b7753806c42b76e782d917e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf68b9b0c9cd17179e9e144c3e7f9c45"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#abf68b9b0c9cd17179e9e144c3e7f9c45">maskIRQ</a> (bool tx_ok, bool tx_fail, bool rx_ready)</td></tr>
<tr class="separator:abf68b9b0c9cd17179e9e144c3e7f9c45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5aea7f9a3bd9c7d357fb296ce751f21"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#ad5aea7f9a3bd9c7d357fb296ce751f21">setAddressWidth</a> (uint8_t a_width)</td></tr>
<tr class="separator:ad5aea7f9a3bd9c7d357fb296ce751f21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9944d93994a80037e3586f340f5e0107"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a9944d93994a80037e3586f340f5e0107">closeReadingPipe</a> (uint8_t pipe)</td></tr>
<tr class="separator:a9944d93994a80037e3586f340f5e0107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Deprecated</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Methods provided for backwards compabibility. </p>
</div></td></tr>
<tr class="memitem:aa7e8523f86f9f8f20c274e0c89a5fd45"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#aa7e8523f86f9f8f20c274e0c89a5fd45">openReadingPipe</a> (uint8_t number, uint64_t address)</td></tr>
<tr class="separator:aa7e8523f86f9f8f20c274e0c89a5fd45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50c8e68ee840e1860a31dbdc83afbd77"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a50c8e68ee840e1860a31dbdc83afbd77">openWritingPipe</a> (uint64_t address)</td></tr>
<tr class="separator:a50c8e68ee840e1860a31dbdc83afbd77"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Optional Configurators</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpe1a83b99ec8153e5baf680edeeed1586"></a> Methods you can use to get or set the configuration of the chip. None are required. Calling <a class="el" href="classRF24.html#a9e720d303ad594de611a813c69244517">begin()</a> sets up a reasonable set of defaults. </p>
</td></tr>
<tr class="memitem:a2e40fe66d1231a333aa2534e8491f828"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a2e40fe66d1231a333aa2534e8491f828">failureDetected</a></td></tr>
<tr class="separator:a2e40fe66d1231a333aa2534e8491f828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c6d3959c8320e64568395f4ef507aef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a4c6d3959c8320e64568395f4ef507aef">setRetries</a> (uint8_t delay, uint8_t count)</td></tr>
<tr class="separator:a4c6d3959c8320e64568395f4ef507aef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e6e5a5f6c85d2638381cab2c0f3702e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a5e6e5a5f6c85d2638381cab2c0f3702e">setChannel</a> (uint8_t channel)</td></tr>
<tr class="separator:a5e6e5a5f6c85d2638381cab2c0f3702e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a343e5d23477181011dea030fafb1954f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a343e5d23477181011dea030fafb1954f">setPayloadSize</a> (uint8_t size)</td></tr>
<tr class="separator:a343e5d23477181011dea030fafb1954f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aa0c7cbe3d38fef4722f3f1d2d6c5f1"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a0aa0c7cbe3d38fef4722f3f1d2d6c5f1">getPayloadSize</a> (void)</td></tr>
<tr class="separator:a0aa0c7cbe3d38fef4722f3f1d2d6c5f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65963ed8d8fd45f847e2f673995b85e1"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a65963ed8d8fd45f847e2f673995b85e1">getDynamicPayloadSize</a> (void)</td></tr>
<tr class="separator:a65963ed8d8fd45f847e2f673995b85e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf8efced2ee9edbcc6510878b20edc1b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#abf8efced2ee9edbcc6510878b20edc1b">enableAckPayload</a> (void)</td></tr>
<tr class="separator:abf8efced2ee9edbcc6510878b20edc1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a443888504975d7441d6452a09d09a8fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a443888504975d7441d6452a09d09a8fa">enableDynamicPayloads</a> (void)</td></tr>
<tr class="separator:a443888504975d7441d6452a09d09a8fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62846750b82682beb7593719eb60ed60"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a62846750b82682beb7593719eb60ed60">isPVariant</a> (void)</td></tr>
<tr class="separator:a62846750b82682beb7593719eb60ed60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec71746d59da978bcbb975167886a2cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#aec71746d59da978bcbb975167886a2cc">setAutoAck</a> (bool enable)</td></tr>
<tr class="separator:aec71746d59da978bcbb975167886a2cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60dba9e558f3620ab489af68ea3dea9c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a60dba9e558f3620ab489af68ea3dea9c">setAutoAck</a> (uint8_t pipe, bool enable)</td></tr>
<tr class="separator:a60dba9e558f3620ab489af68ea3dea9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adedac579590a668ae97baccab284de8a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#adedac579590a668ae97baccab284de8a">setPALevel</a> (uint8_t level)</td></tr>
<tr class="separator:adedac579590a668ae97baccab284de8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7c4dcd84466168c5816382ceb366067"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#af7c4dcd84466168c5816382ceb366067">getPALevel</a> (void)</td></tr>
<tr class="separator:af7c4dcd84466168c5816382ceb366067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb9920e7a95699748b003c4a839b0814"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#aeb9920e7a95699748b003c4a839b0814">setDataRate</a> (rf24_datarate_e speed)</td></tr>
<tr class="separator:aeb9920e7a95699748b003c4a839b0814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72a7b11dafe8ffab6135f243decce0d7"><td class="memItemLeft" align="right" valign="top">rf24_datarate_e&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a72a7b11dafe8ffab6135f243decce0d7">getDataRate</a> (void)</td></tr>
<tr class="separator:a72a7b11dafe8ffab6135f243decce0d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89f626fc4a58dd997153bcc0f8198b9e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a89f626fc4a58dd997153bcc0f8198b9e">setCRCLength</a> (rf24_crclength_e length)</td></tr>
<tr class="separator:a89f626fc4a58dd997153bcc0f8198b9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba4ca91b829afcd94a4c11e0343e3796"><td class="memItemLeft" align="right" valign="top">rf24_crclength_e&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#aba4ca91b829afcd94a4c11e0343e3796">getCRCLength</a> (void)</td></tr>
<tr class="separator:aba4ca91b829afcd94a4c11e0343e3796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eacd9ecfbc19864801d714c292cf8be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF24.html#a5eacd9ecfbc19864801d714c292cf8be">disableCRC</a> (void)</td></tr>
<tr class="separator:a5eacd9ecfbc19864801d714c292cf8be"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Driver for nRF24L01(+) 2.4GHz Wireless Transceiver </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="GettingStarted_8ino-example.html#_a0">GettingStarted.ino</a>, <a class="el" href="GettingStarted_CallResponse_8ino-example.html#_a0">GettingStarted_CallResponse.ino</a>, <a class="el" href="led_remote_8pde-example.html#_a0">led_remote.pde</a>, <a class="el" href="nordic_fob_8pde-example.html#_a0">nordic_fob.pde</a>, <a class="el" href="pingpair_ack_8ino-example.html#_a0">pingpair_ack.ino</a>, <a class="el" href="pingpair_dyn_8ino-example.html#_a0">pingpair_dyn.ino</a>, <a class="el" href="pingpair_irq_8ino-example.html#_a0">pingpair_irq.ino</a>, <a class="el" href="pingpair_maple_8pde-example.html#_a0">pingpair_maple.pde</a>, <a class="el" href="pingpair_sleepy_8ino-example.html#_a0">pingpair_sleepy.ino</a>, <a class="el" href="scanner_8ino-example.html#_a0">scanner.ino</a>, <a class="el" href="starping_8pde-example.html#_a0">starping.pde</a>, <a class="el" href="Transfer_8ino-example.html#_a0">Transfer.ino</a>, and <a class="el" href="TransferTimeouts_8ino-example.html#_a0">TransferTimeouts.ino</a>.</dd>
</dl></div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a8cd165a822c8f77e10782c6729c5b088"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RF24::RF24 </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>_cepin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>_cspin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor</p>
<p>Creates a new instance of this driver. Before using, you create an instance and send in the unique pins that this chip is connected to.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_cepin</td><td>The pin attached to Chip Enable on the RF module </td></tr>
    <tr><td class="paramname">_cspin</td><td>The pin attached to Chip Select </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a9e720d303ad594de611a813c69244517"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::begin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Begin operation of the chip</p>
<p>Call this in setup(), before calling any other methods. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="GettingStarted_8ino-example.html#a1">GettingStarted.ino</a>, <a class="el" href="GettingStarted_CallResponse_8ino-example.html#a1">GettingStarted_CallResponse.ino</a>, <a class="el" href="led_remote_8pde-example.html#a1">led_remote.pde</a>, <a class="el" href="nordic_fob_8pde-example.html#a1">nordic_fob.pde</a>, <a class="el" href="pingpair_ack_8ino-example.html#a1">pingpair_ack.ino</a>, <a class="el" href="pingpair_dyn_8ino-example.html#a1">pingpair_dyn.ino</a>, <a class="el" href="pingpair_irq_8ino-example.html#a1">pingpair_irq.ino</a>, <a class="el" href="pingpair_maple_8pde-example.html#a1">pingpair_maple.pde</a>, <a class="el" href="pingpair_sleepy_8ino-example.html#a1">pingpair_sleepy.ino</a>, <a class="el" href="scanner_8ino-example.html#a1">scanner.ino</a>, <a class="el" href="starping_8pde-example.html#a1">starping.pde</a>, <a class="el" href="Transfer_8ino-example.html#a1">Transfer.ino</a>, and <a class="el" href="TransferTimeouts_8ino-example.html#a1">TransferTimeouts.ino</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a30a2733a3889bdc331fe2d2f4f0f7b39"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::startListening </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start listening on the pipes opened for reading.</p>
<p>Be sure to call <a class="el" href="classRF24.html#a9edc910ccc1ffcff56814b08faca5535">openReadingPipe()</a> first. Do not call <a class="el" href="classRF24.html#a4cd4c198a47704db20b6b5cf0731cd58">write()</a> while in this mode, without first calling <a class="el" href="classRF24.html#a6f144d73fc447c8ac2d1a4166210fd88">stopListening()</a>. Call Available() to check for incoming traffic, and <a class="el" href="classRF24.html#a8e2eacacfba96426c192066f04054c5b">read()</a> to get it. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="GettingStarted_8ino-example.html#a6">GettingStarted.ino</a>, <a class="el" href="GettingStarted_CallResponse_8ino-example.html#a9">GettingStarted_CallResponse.ino</a>, <a class="el" href="led_remote_8pde-example.html#a4">led_remote.pde</a>, <a class="el" href="nordic_fob_8pde-example.html#a7">nordic_fob.pde</a>, <a class="el" href="pingpair_ack_8ino-example.html#a8">pingpair_ack.ino</a>, <a class="el" href="pingpair_dyn_8ino-example.html#a6">pingpair_dyn.ino</a>, <a class="el" href="pingpair_irq_8ino-example.html#a5">pingpair_irq.ino</a>, <a class="el" href="pingpair_maple_8pde-example.html#a6">pingpair_maple.pde</a>, <a class="el" href="pingpair_sleepy_8ino-example.html#a4">pingpair_sleepy.ino</a>, <a class="el" href="scanner_8ino-example.html#a3">scanner.ino</a>, <a class="el" href="starping_8pde-example.html#a4">starping.pde</a>, <a class="el" href="Transfer_8ino-example.html#a10">Transfer.ino</a>, and <a class="el" href="TransferTimeouts_8ino-example.html#a10">TransferTimeouts.ino</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a6f144d73fc447c8ac2d1a4166210fd88"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::stopListening </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stop listening for incoming messages</p>
<p>Do this before calling <a class="el" href="classRF24.html#a4cd4c198a47704db20b6b5cf0731cd58">write()</a>. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="GettingStarted_8ino-example.html#a8">GettingStarted.ino</a>, <a class="el" href="GettingStarted_CallResponse_8ino-example.html#a12">GettingStarted_CallResponse.ino</a>, <a class="el" href="pingpair_ack_8ino-example.html#a10">pingpair_ack.ino</a>, <a class="el" href="pingpair_dyn_8ino-example.html#a8">pingpair_dyn.ino</a>, <a class="el" href="pingpair_maple_8pde-example.html#a8">pingpair_maple.pde</a>, <a class="el" href="pingpair_sleepy_8ino-example.html#a6">pingpair_sleepy.ino</a>, <a class="el" href="scanner_8ino-example.html#a4">scanner.ino</a>, <a class="el" href="starping_8pde-example.html#a6">starping.pde</a>, <a class="el" href="Transfer_8ino-example.html#a17">Transfer.ino</a>, and <a class="el" href="TransferTimeouts_8ino-example.html#a18">TransferTimeouts.ino</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a127105eb7a3b351cfe777c1cec50627a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RF24::available </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Test whether there are bytes available to be read</p>
<dl class="section return"><dt>Returns</dt><dd>True if there is a payload available, false if none is </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="GettingStarted_8ino-example.html#a10">GettingStarted.ino</a>, <a class="el" href="GettingStarted_CallResponse_8ino-example.html#a14">GettingStarted_CallResponse.ino</a>, <a class="el" href="led_remote_8pde-example.html#a7">led_remote.pde</a>, <a class="el" href="nordic_fob_8pde-example.html#a9">nordic_fob.pde</a>, <a class="el" href="pingpair_ack_8ino-example.html#a12">pingpair_ack.ino</a>, <a class="el" href="pingpair_dyn_8ino-example.html#a10">pingpair_dyn.ino</a>, <a class="el" href="pingpair_irq_8ino-example.html#a9">pingpair_irq.ino</a>, <a class="el" href="pingpair_maple_8pde-example.html#a10">pingpair_maple.pde</a>, <a class="el" href="pingpair_sleepy_8ino-example.html#a8">pingpair_sleepy.ino</a>, <a class="el" href="starping_8pde-example.html#a8">starping.pde</a>, <a class="el" href="Transfer_8ino-example.html#a15">Transfer.ino</a>, and <a class="el" href="TransferTimeouts_8ino-example.html#a16">TransferTimeouts.ino</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a8e2eacacfba96426c192066f04054c5b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::read </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read the payload</p>
<p>The size of data read is the fixed payload size, see <a class="el" href="classRF24.html#a0aa0c7cbe3d38fef4722f3f1d2d6c5f1">getPayloadSize()</a></p>
<dl class="section note"><dt>Note</dt><dd>I specifically chose 'void*' as a data type to make it easier for beginners to use. No casting needed.</dd>
<dd>
No longer boolean. Use available to determine if packets are available. Interrupt flags are now cleared during reads instead of when calling <a class="el" href="classRF24.html#a127105eb7a3b351cfe777c1cec50627a">available()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Pointer to a buffer where the data should be written </td></tr>
    <tr><td class="paramname">len</td><td>Maximum number of bytes to read into the buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>No return value. Use <a class="el" href="classRF24.html#a127105eb7a3b351cfe777c1cec50627a">available()</a>. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="GettingStarted_8ino-example.html#a11">GettingStarted.ino</a>, <a class="el" href="GettingStarted_CallResponse_8ino-example.html#a15">GettingStarted_CallResponse.ino</a>, <a class="el" href="led_remote_8pde-example.html#a8">led_remote.pde</a>, <a class="el" href="nordic_fob_8pde-example.html#a10">nordic_fob.pde</a>, <a class="el" href="pingpair_ack_8ino-example.html#a13">pingpair_ack.ino</a>, <a class="el" href="pingpair_dyn_8ino-example.html#a12">pingpair_dyn.ino</a>, <a class="el" href="pingpair_irq_8ino-example.html#a10">pingpair_irq.ino</a>, <a class="el" href="pingpair_maple_8pde-example.html#a11">pingpair_maple.pde</a>, <a class="el" href="pingpair_sleepy_8ino-example.html#a9">pingpair_sleepy.ino</a>, <a class="el" href="starping_8pde-example.html#a9">starping.pde</a>, <a class="el" href="Transfer_8ino-example.html#a16">Transfer.ino</a>, and <a class="el" href="TransferTimeouts_8ino-example.html#a17">TransferTimeouts.ino</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a4cd4c198a47704db20b6b5cf0731cd58"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RF24::write </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Be sure to call <a class="el" href="classRF24.html#af2e409e62d49a23e372a70b904ae30e1">openWritingPipe()</a> first to set the destination of where to write to.</p>
<p>This blocks until the message is successfully acknowledged by the receiver or the timeout/retransmit maxima are reached. In the current configuration, the max delay here is 60-70ms.</p>
<p>The maximum size of data written is the fixed payload size, see <a class="el" href="classRF24.html#a0aa0c7cbe3d38fef4722f3f1d2d6c5f1">getPayloadSize()</a>. However, you can write less, and the remainder will just be filled with zeroes.</p>
<p>TX/RX/RT interrupt flags will be cleared every time write is called</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Pointer to the data to be sent </td></tr>
    <tr><td class="paramname">len</td><td>Number of bytes to be sent </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the payload was delivered successfully false if not </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="GettingStarted_8ino-example.html#a9">GettingStarted.ino</a>, <a class="el" href="GettingStarted_CallResponse_8ino-example.html#a13">GettingStarted_CallResponse.ino</a>, <a class="el" href="led_remote_8pde-example.html#a6">led_remote.pde</a>, <a class="el" href="pingpair_ack_8ino-example.html#a11">pingpair_ack.ino</a>, <a class="el" href="pingpair_dyn_8ino-example.html#a9">pingpair_dyn.ino</a>, <a class="el" href="pingpair_maple_8pde-example.html#a9">pingpair_maple.pde</a>, <a class="el" href="pingpair_sleepy_8ino-example.html#a7">pingpair_sleepy.ino</a>, and <a class="el" href="starping_8pde-example.html#a7">starping.pde</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="af2e409e62d49a23e372a70b904ae30e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::openWritingPipe </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>New: Open a pipe for writing via byte array. Old addressing format retained for compatibility.</p>
<p>Only one writing pipe can be open at once, but you can change the address you'll write to. Call <a class="el" href="classRF24.html#a6f144d73fc447c8ac2d1a4166210fd88">stopListening()</a> first.</p>
<p>Addresses are assigned via a byte array, default is 5 byte address length</p>
<p>Usage is exactly the same as before, except for declaring the array</p>
<div class="fragment"><div class="line">uint8_t addresses[][6] = {<span class="stringliteral">&quot;1Node&quot;</span>,<span class="stringliteral">&quot;2Node&quot;</span>};</div>
<div class="line"><a class="code" href="classRF24.html#af2e409e62d49a23e372a70b904ae30e1">openWritingPipe</a>(addresses[0]);</div>
</div><!-- fragment --> <dl class="section see"><dt>See Also</dt><dd><a class="el" href="classRF24.html#ad5aea7f9a3bd9c7d357fb296ce751f21">setAddressWidth</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>The address of the pipe to open. Coordinate these pipe addresses amongst nodes on the network. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="GettingStarted_8ino-example.html#a4">GettingStarted.ino</a>, <a class="el" href="GettingStarted_CallResponse_8ino-example.html#a7">GettingStarted_CallResponse.ino</a>, <a class="el" href="led_remote_8pde-example.html#a2">led_remote.pde</a>, <a class="el" href="pingpair_ack_8ino-example.html#a6">pingpair_ack.ino</a>, <a class="el" href="pingpair_dyn_8ino-example.html#a4">pingpair_dyn.ino</a>, <a class="el" href="pingpair_irq_8ino-example.html#a3">pingpair_irq.ino</a>, <a class="el" href="pingpair_maple_8pde-example.html#a4">pingpair_maple.pde</a>, <a class="el" href="pingpair_sleepy_8ino-example.html#a2">pingpair_sleepy.ino</a>, <a class="el" href="starping_8pde-example.html#a3">starping.pde</a>, <a class="el" href="Transfer_8ino-example.html#a8">Transfer.ino</a>, and <a class="el" href="TransferTimeouts_8ino-example.html#a8">TransferTimeouts.ino</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a9edc910ccc1ffcff56814b08faca5535"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::openReadingPipe </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Open a pipe for reading</p>
<p>Up to 6 pipes can be open for reading at once. Open all the reading pipes, and then call <a class="el" href="classRF24.html#a30a2733a3889bdc331fe2d2f4f0f7b39">startListening()</a>.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classRF24.html#af2e409e62d49a23e372a70b904ae30e1">openWritingPipe</a> </dd>
<dd>
<a class="el" href="classRF24.html#ad5aea7f9a3bd9c7d357fb296ce751f21">setAddressWidth</a></dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Pipes 1-5 should share the same address, except the first byte. Only the first byte in the array should be unique, e.g. <div class="fragment"><div class="line">uint8_t addresses[][6] = {<span class="stringliteral">&quot;1Node&quot;</span>,<span class="stringliteral">&quot;2Node&quot;</span>};</div>
<div class="line"><a class="code" href="classRF24.html#a9edc910ccc1ffcff56814b08faca5535">openReadingPipe</a>(1,addresses[0]);</div>
<div class="line"><a class="code" href="classRF24.html#a9edc910ccc1ffcff56814b08faca5535">openReadingPipe</a>(2,addresses[1]);</div>
</div><!-- fragment --></dd>
<dd>
Pipe 0 is also used by the writing pipe. So if you open pipe 0 for reading, and then <a class="el" href="classRF24.html#a30a2733a3889bdc331fe2d2f4f0f7b39">startListening()</a>, it will overwrite the writing pipe. Ergo, do an <a class="el" href="classRF24.html#af2e409e62d49a23e372a70b904ae30e1">openWritingPipe()</a> again before <a class="el" href="classRF24.html#a4cd4c198a47704db20b6b5cf0731cd58">write()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">number</td><td>Which pipe# to open, 0-5. </td></tr>
    <tr><td class="paramname">address</td><td>The 24, 32 or 40 bit address of the pipe to open. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="GettingStarted_8ino-example.html#a5">GettingStarted.ino</a>, <a class="el" href="GettingStarted_CallResponse_8ino-example.html#a8">GettingStarted_CallResponse.ino</a>, <a class="el" href="led_remote_8pde-example.html#a3">led_remote.pde</a>, <a class="el" href="nordic_fob_8pde-example.html#a6">nordic_fob.pde</a>, <a class="el" href="pingpair_ack_8ino-example.html#a7">pingpair_ack.ino</a>, <a class="el" href="pingpair_dyn_8ino-example.html#a5">pingpair_dyn.ino</a>, <a class="el" href="pingpair_irq_8ino-example.html#a4">pingpair_irq.ino</a>, <a class="el" href="pingpair_maple_8pde-example.html#a5">pingpair_maple.pde</a>, <a class="el" href="pingpair_sleepy_8ino-example.html#a3">pingpair_sleepy.ino</a>, <a class="el" href="starping_8pde-example.html#a2">starping.pde</a>, <a class="el" href="Transfer_8ino-example.html#a9">Transfer.ino</a>, and <a class="el" href="TransferTimeouts_8ino-example.html#a9">TransferTimeouts.ino</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="adc95213ed4c8569a90eb33122e16cea6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::printDetails </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print a giant block of debugging information to stdout</p>
<dl class="section warning"><dt>Warning</dt><dd>Does nothing if stdout is not defined. See fdevopen in stdio.h </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="GettingStarted_8ino-example.html#a7">GettingStarted.ino</a>, <a class="el" href="GettingStarted_CallResponse_8ino-example.html#a11">GettingStarted_CallResponse.ino</a>, <a class="el" href="led_remote_8pde-example.html#a5">led_remote.pde</a>, <a class="el" href="nordic_fob_8pde-example.html#a8">nordic_fob.pde</a>, <a class="el" href="pingpair_ack_8ino-example.html#a9">pingpair_ack.ino</a>, <a class="el" href="pingpair_dyn_8ino-example.html#a7">pingpair_dyn.ino</a>, <a class="el" href="pingpair_irq_8ino-example.html#a6">pingpair_irq.ino</a>, <a class="el" href="pingpair_maple_8pde-example.html#a7">pingpair_maple.pde</a>, <a class="el" href="starping_8pde-example.html#a5">starping.pde</a>, <a class="el" href="Transfer_8ino-example.html#a11">Transfer.ino</a>, and <a class="el" href="TransferTimeouts_8ino-example.html#a11">TransferTimeouts.ino</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ace7dd139fabc16b77cb8325faa07620f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RF24::available </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pipe_num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Test whether there are bytes available to be read in the FIFO buffers. This optimized version does not rely on interrupt flags, but checks the actual FIFO buffers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pipe_num</td><td>Which pipe has the payload available </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if there is a payload available, false if none is </dd></dl>

</div>
</div>
<a class="anchor" id="aa0a51923a09ba4f3478aba9be0f8a6a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::powerDown </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enter low-power mode</p>
<p>To return to normal power mode, either <a class="el" href="classRF24.html#a4cd4c198a47704db20b6b5cf0731cd58">write()</a> some data or startListening, or <a class="el" href="classRF24.html#a5cdaf47aa0edd6dca1b9a8bb7972a1a3">powerUp()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>After calling <a class="el" href="classRF24.html#a30a2733a3889bdc331fe2d2f4f0f7b39">startListening()</a>, a basic radio will consume about 13.5mA at max PA level. During active transmission, the radio will consume about 11.5mA, but this will be reduced to 26uA (.026mA) between sending. In full powerDown mode, the radio will consume approximately 900nA (.0009mA) </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="pingpair_sleepy_8ino-example.html#a10">pingpair_sleepy.ino</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a5cdaf47aa0edd6dca1b9a8bb7972a1a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::powerUp </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Leave low-power mode - required for normal radio operation after calling <a class="el" href="classRF24.html#aa0a51923a09ba4f3478aba9be0f8a6a1">powerDown()</a></p>
<p>To return to low power mode, call <a class="el" href="classRF24.html#aa0a51923a09ba4f3478aba9be0f8a6a1">powerDown()</a>. </p>
<dl class="section note"><dt>Note</dt><dd>This will take up to 5ms for maximum compatibility </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="GettingStarted_CallResponse_8ino-example.html#a10">GettingStarted_CallResponse.ino</a>, <a class="el" href="pingpair_sleepy_8ino-example.html#a5">pingpair_sleepy.ino</a>, <a class="el" href="Transfer_8ino-example.html#a12">Transfer.ino</a>, and <a class="el" href="TransferTimeouts_8ino-example.html#a12">TransferTimeouts.ino</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a23bfe6502d74bb5bbccb3a7f2ba2b5ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RF24::write </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>multicast</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write for single NOACK writes. Optionally disables acknowledgements/autoretries for a single write.</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classRF24.html#a6253607ac2a1995af91a35cea6899c31">enableDynamicAck()</a> must be called to enable this feature</dd></dl>
<p>Can be used with <a class="el" href="classRF24.html#abf8efced2ee9edbcc6510878b20edc1b">enableAckPayload()</a> to request a response </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classRF24.html#a6253607ac2a1995af91a35cea6899c31">enableDynamicAck()</a> </dd>
<dd>
<a class="el" href="classRF24.html#aec71746d59da978bcbb975167886a2cc">setAutoAck()</a> </dd>
<dd>
<a class="el" href="classRF24.html#a4cd4c198a47704db20b6b5cf0731cd58">write()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Pointer to the data to be sent </td></tr>
    <tr><td class="paramname">len</td><td>Number of bytes to be sent </td></tr>
    <tr><td class="paramname">multicast</td><td>Request ACK (0), NOACK (1) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a47b2516993481b58e724d1274a7fd9cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RF24::writeFast </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This will not block until the 3 FIFO buffers are filled with data. Once the FIFOs are full, writeFast will simply wait for success or timeout, and return 1 or 0 respectively. From a user perspective, just keep trying to send the same data. The library will keep auto retrying the current payload using the built in functionality. </p>
<dl class="section warning"><dt>Warning</dt><dd>It is important to never keep the nRF24L01 in TX mode and FIFO full for more than 4ms at a time. If the auto retransmit is enabled, the nRF24L01 is never in TX mode long enough to disobey this rule. Allow the FIFO to clear by issuing <a class="el" href="classRF24.html#a12cc453453c94969d4d3f0edb3778c83">txStandBy()</a> or ensure appropriate time between transmissions.</dd></dl>
<p>ONLY max retry interrupt flags will be cleared when writeFast is called</p>
<div class="fragment"><div class="line">Example (Partial blocking):</div>
<div class="line"></div>
<div class="line">        radio.<a class="code" href="classRF24.html#a47b2516993481b58e724d1274a7fd9cb">writeFast</a>(&amp;buf,32);  <span class="comment">// Writes 1 payload to the buffers</span></div>
<div class="line">        <a class="code" href="classRF24.html#a12cc453453c94969d4d3f0edb3778c83">txStandBy</a>();               <span class="comment">// Returns 0 if failed. 1 if success. Blocks only until MAX_RT timeout or success. Data flushed on fail.</span></div>
<div class="line"></div>
<div class="line">        radio.<a class="code" href="classRF24.html#a47b2516993481b58e724d1274a7fd9cb">writeFast</a>(&amp;buf,32);  <span class="comment">// Writes 1 payload to the buffers</span></div>
<div class="line">        <a class="code" href="classRF24.html#a12cc453453c94969d4d3f0edb3778c83">txStandBy</a>(1000);           <span class="comment">// Using extended timeouts, returns 1 if success. Retries failed payloads for 1 seconds before returning 0.</span></div>
</div><!-- fragment --><dl class="section see"><dt>See Also</dt><dd><a class="el" href="classRF24.html#a12cc453453c94969d4d3f0edb3778c83">txStandBy()</a> </dd>
<dd>
<a class="el" href="classRF24.html#a4cd4c198a47704db20b6b5cf0731cd58">write()</a> </dd>
<dd>
<a class="el" href="classRF24.html#ae6fd8d5ee490d54ae1cb2e8fefee535f">writeBlocking()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Pointer to the data to be sent </td></tr>
    <tr><td class="paramname">len</td><td>Number of bytes to be sent </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the payload was delivered successfully false if not </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="Transfer_8ino-example.html#a13">Transfer.ino</a>, and <a class="el" href="TransferTimeouts_8ino-example.html#a13">TransferTimeouts.ino</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ad16d53de0327c0b41d170cbda4bf41af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RF24::writeFast </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>multicast</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>WriteFast for single NOACK writes. Disables acknowledgements/autoretries for a single write.</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classRF24.html#a6253607ac2a1995af91a35cea6899c31">enableDynamicAck()</a> must be called to enable this feature </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classRF24.html#a6253607ac2a1995af91a35cea6899c31">enableDynamicAck()</a> </dd>
<dd>
<a class="el" href="classRF24.html#aec71746d59da978bcbb975167886a2cc">setAutoAck()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Pointer to the data to be sent </td></tr>
    <tr><td class="paramname">len</td><td>Number of bytes to be sent </td></tr>
    <tr><td class="paramname">multicast</td><td>Request ACK (0) or NOACK (1) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae6fd8d5ee490d54ae1cb2e8fefee535f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RF24::writeBlocking </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function extends the auto-retry mechanism to any specified duration. It will not block until the 3 FIFO buffers are filled with data. If so the library will auto retry until a new payload is written or the user specified timeout period is reached. </p>
<dl class="section warning"><dt>Warning</dt><dd>It is important to never keep the nRF24L01 in TX mode and FIFO full for more than 4ms at a time. If the auto retransmit is enabled, the nRF24L01 is never in TX mode long enough to disobey this rule. Allow the FIFO to clear by issuing <a class="el" href="classRF24.html#a12cc453453c94969d4d3f0edb3778c83">txStandBy()</a> or ensure appropriate time between transmissions.</dd></dl>
<p>ONLY max retry interrupt flags will be cleared when writeBlocking is called </p>
<div class="fragment"><div class="line">Example (Full blocking):</div>
<div class="line"></div>
<div class="line">        radio.<a class="code" href="classRF24.html#ae6fd8d5ee490d54ae1cb2e8fefee535f">writeBlocking</a>(&amp;buf,32,1000); <span class="comment">//Wait up to 1 second to write 1 payload to the buffers</span></div>
<div class="line">        <a class="code" href="classRF24.html#a12cc453453c94969d4d3f0edb3778c83">txStandBy</a>(1000);                   <span class="comment">//Wait up to 1 second for the payload to send. Return 1 if ok, 0 if failed.</span></div>
<div class="line">                                           <span class="comment">//Blocks only until user timeout or success. Data flushed on fail.</span></div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>If used from within an interrupt, the interrupt should be disabled until completion, and sei(); called to enable millis(). </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classRF24.html#a12cc453453c94969d4d3f0edb3778c83">txStandBy()</a> </dd>
<dd>
<a class="el" href="classRF24.html#a4cd4c198a47704db20b6b5cf0731cd58">write()</a> </dd>
<dd>
<a class="el" href="classRF24.html#a47b2516993481b58e724d1274a7fd9cb">writeFast()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Pointer to the data to be sent </td></tr>
    <tr><td class="paramname">len</td><td>Number of bytes to be sent </td></tr>
    <tr><td class="paramname">timeout</td><td>User defined timeout in milliseconds. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the payload was loaded into the buffer successfully false if not </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="TransferTimeouts_8ino-example.html#a15">TransferTimeouts.ino</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a12cc453453c94969d4d3f0edb3778c83"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RF24::txStandBy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function should be called as soon as transmission is finished to drop the radio back to STANDBY-I mode. If not issued, the radio will remain in STANDBY-II mode which, per the data sheet, is not a recommended operating mode.</p>
<dl class="section note"><dt>Note</dt><dd>When transmitting data in rapid succession, it is still recommended by the manufacturer to drop the radio out of TX or STANDBY-II mode if there is time enough between sends for the FIFOs to empty.</dd></dl>
<p>Relies on built-in auto retry functionality.</p>
<div class="fragment"><div class="line">Example (Partial blocking):</div>
<div class="line"></div>
<div class="line">        radio.<a class="code" href="classRF24.html#a47b2516993481b58e724d1274a7fd9cb">writeFast</a>(&amp;buf,32);</div>
<div class="line">        radio.<a class="code" href="classRF24.html#a47b2516993481b58e724d1274a7fd9cb">writeFast</a>(&amp;buf,32);</div>
<div class="line">        radio.<a class="code" href="classRF24.html#a47b2516993481b58e724d1274a7fd9cb">writeFast</a>(&amp;buf,32);  <span class="comment">//Fills the FIFO buffers up</span></div>
<div class="line">        <span class="keywordtype">bool</span> ok = <a class="code" href="classRF24.html#a12cc453453c94969d4d3f0edb3778c83">txStandBy</a>();     <span class="comment">//Returns 0 if failed. 1 if success.</span></div>
<div class="line">                                   <span class="comment">//Blocks only until MAX_RT timeout or success. Data flushed on fail.</span></div>
</div><!-- fragment --> <dl class="section see"><dt>See Also</dt><dd>txStandBy(unsigned long timeout) </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>True if transmission is successful </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="Transfer_8ino-example.html#a14">Transfer.ino</a>, and <a class="el" href="TransferTimeouts_8ino-example.html#a14">TransferTimeouts.ino</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="aa6f36353c1bdfbaf3c530d118cb84baa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RF24::txStandBy </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function allows extended blocking and auto-retries per a user defined timeout </p>
<div class="fragment"><div class="line">Fully Blocking Example:</div>
<div class="line"></div>
<div class="line">     radio.<a class="code" href="classRF24.html#a47b2516993481b58e724d1274a7fd9cb">writeFast</a>(&amp;buf,32);</div>
<div class="line">     radio.<a class="code" href="classRF24.html#a47b2516993481b58e724d1274a7fd9cb">writeFast</a>(&amp;buf,32);</div>
<div class="line">     radio.<a class="code" href="classRF24.html#a47b2516993481b58e724d1274a7fd9cb">writeFast</a>(&amp;buf,32);   <span class="comment">//Fills the FIFO buffers up</span></div>
<div class="line">     <span class="keywordtype">bool</span> ok = <a class="code" href="classRF24.html#a12cc453453c94969d4d3f0edb3778c83">txStandBy</a>(1000);  <span class="comment">//Returns 0 if failed after 1 second of retries. 1 if success.</span></div>
<div class="line">                                 <span class="comment">//Blocks only until user defined timeout or success. Data flushed on fail.</span></div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>If used from within an interrupt, the interrupt should be disabled until completion, and sei(); called to enable millis(). </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>Number of milliseconds to retry failed payloads </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if transmission is successful </dd></dl>

</div>
</div>
<a class="anchor" id="a65619238c25036c3de72dc2c1a1c6e52"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::writeAckPayload </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>pipe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write an ack payload for the specified pipe</p>
<p>The next time a message is received on <code>pipe</code>, the data in <code>buf</code> will be sent back in the acknowledgement.</p>
<dl class="section warning"><dt>Warning</dt><dd>Only three of these can be pending at any time as there are only 3 FIFO buffers.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pipe</td><td>Which pipe# (typically 1-5) will get this response. </td></tr>
    <tr><td class="paramname">buf</td><td>Pointer to data that is sent </td></tr>
    <tr><td class="paramname">len</td><td>Length of the data to send, up to 32 bytes max. Not affected by the static payload set by <a class="el" href="classRF24.html#a343e5d23477181011dea030fafb1954f">setPayloadSize()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="GettingStarted_CallResponse_8ino-example.html#a16">GettingStarted_CallResponse.ino</a>, <a class="el" href="pingpair_ack_8ino-example.html#a14">pingpair_ack.ino</a>, and <a class="el" href="pingpair_irq_8ino-example.html#a11">pingpair_irq.ino</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a6253607ac2a1995af91a35cea6899c31"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::enableDynamicAck </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable dynamic ACKs (single write multicasting) for chosen messages</p>
<dl class="section note"><dt>Note</dt><dd>To enable full multicasting or per-pipe multicast, use <a class="el" href="classRF24.html#aec71746d59da978bcbb975167886a2cc">setAutoAck()</a></dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This MUST be called prior to attempting single write NOACK calls <div class="fragment"><div class="line">radio.<a class="code" href="classRF24.html#a6253607ac2a1995af91a35cea6899c31">enableDynamicAck</a>();</div>
<div class="line">radio.<a class="code" href="classRF24.html#a4cd4c198a47704db20b6b5cf0731cd58">write</a>(&amp;data,32,1);  <span class="comment">// Sends a payload with no acknowledgement requested</span></div>
<div class="line">radio.<a class="code" href="classRF24.html#a4cd4c198a47704db20b6b5cf0731cd58">write</a>(&amp;data,32,0);  <span class="comment">// Sends a payload using auto-retry/autoACK</span></div>
</div><!-- fragment --> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="GettingStarted_CallResponse_8ino-example.html#a4">GettingStarted_CallResponse.ino</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a30c2736fd0df9c8128cef408c8b88e92"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RF24::isAckPayloadAvailable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine if an ack payload was received in the most recent call to <a class="el" href="classRF24.html#a4cd4c198a47704db20b6b5cf0731cd58">write()</a>. The regular <a class="el" href="classRF24.html#a127105eb7a3b351cfe777c1cec50627a">available()</a> can also be used.</p>
<p>Call <a class="el" href="classRF24.html#a8e2eacacfba96426c192066f04054c5b">read()</a> to retrieve the ack payload.</p>
<dl class="section return"><dt>Returns</dt><dd>True if an ack payload is available. </dd></dl>

</div>
</div>
<a class="anchor" id="afb97dc4bdf4d2d84ea44060ac5b4ed89"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::whatHappened </td>
          <td>(</td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>tx_ok</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>tx_fail</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>rx_ready</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call this when you get an interrupt to find out why</p>
<p>Tells you what caused the interrupt, and clears the state of interrupts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">tx_ok</td><td>The send was successful (TX_DS) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">tx_fail</td><td>The send failed, too many retries (MAX_RT) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rx_ready</td><td>There is a message waiting to be read (RX_DS) </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="pingpair_irq_8ino-example.html#a8">pingpair_irq.ino</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a7f27a53cda5f707c817c9a89a8425489"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::startFastWrite </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>multicast</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Non-blocking write to the open writing pipe used for buffered writes</p>
<dl class="section note"><dt>Note</dt><dd>Optimization: This function now leaves the CE pin high, so the radio will remain in TX or STANDBY-II Mode until a <a class="el" href="classRF24.html#a12cc453453c94969d4d3f0edb3778c83">txStandBy()</a> command is issued. This allows the chip to be used to its full potential in TX mode. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It is important to never keep the nRF24L01 in TX mode with FIFO full for more than 4ms at a time. If the auto retransmit is enabled, the nRF24L01 is never in TX mode long enough to disobey this rule. Allow the FIFO to clear by issuing <a class="el" href="classRF24.html#a12cc453453c94969d4d3f0edb3778c83">txStandBy()</a> or ensure appropriate time between transmissions.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classRF24.html#a4cd4c198a47704db20b6b5cf0731cd58">write()</a> </dd>
<dd>
<a class="el" href="classRF24.html#a47b2516993481b58e724d1274a7fd9cb">writeFast()</a> </dd>
<dd>
<a class="el" href="classRF24.html#aa27519fc289920094422033e0bbf8cf9">startWrite()</a> </dd>
<dd>
<a class="el" href="classRF24.html#ae6fd8d5ee490d54ae1cb2e8fefee535f">writeBlocking()</a></dd></dl>
<p>For single noAck writes see: </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classRF24.html#a6253607ac2a1995af91a35cea6899c31">enableDynamicAck()</a> </dd>
<dd>
<a class="el" href="classRF24.html#aec71746d59da978bcbb975167886a2cc">setAutoAck()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Pointer to the data to be sent </td></tr>
    <tr><td class="paramname">len</td><td>Number of bytes to be sent </td></tr>
    <tr><td class="paramname">multicast</td><td>Request ACK (0) or NOACK (1) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the payload was delivered successfully false if not </dd></dl>

</div>
</div>
<a class="anchor" id="aa27519fc289920094422033e0bbf8cf9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::startWrite </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>multicast</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Non-blocking write to the open writing pipe</p>
<p>Just like <a class="el" href="classRF24.html#a4cd4c198a47704db20b6b5cf0731cd58">write()</a>, but it returns immediately. To find out what happened to the send, catch the IRQ and then call <a class="el" href="classRF24.html#afb97dc4bdf4d2d84ea44060ac5b4ed89">whatHappened()</a>.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classRF24.html#a4cd4c198a47704db20b6b5cf0731cd58">write()</a> </dd>
<dd>
<a class="el" href="classRF24.html#a47b2516993481b58e724d1274a7fd9cb">writeFast()</a> </dd>
<dd>
<a class="el" href="classRF24.html#a7f27a53cda5f707c817c9a89a8425489">startFastWrite()</a> </dd>
<dd>
<a class="el" href="classRF24.html#afb97dc4bdf4d2d84ea44060ac5b4ed89">whatHappened()</a></dd></dl>
<p>For single noAck writes see: </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classRF24.html#a6253607ac2a1995af91a35cea6899c31">enableDynamicAck()</a> </dd>
<dd>
<a class="el" href="classRF24.html#aec71746d59da978bcbb975167886a2cc">setAutoAck()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Pointer to the data to be sent </td></tr>
    <tr><td class="paramname">len</td><td>Number of bytes to be sent </td></tr>
    <tr><td class="paramname">multicast</td><td>Request ACK (0) or NOACK (1) </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="pingpair_irq_8ino-example.html#a7">pingpair_irq.ino</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="aeaf7fa54d3ab2a85ce215b4bf6ae933b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::reUseTX </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is mainly used internally to take advantage of the auto payload re-use functionality of the chip, but can be beneficial to users as well.</p>
<p>The function will instruct the radio to re-use the data in the FIFO buffers, and instructs the radio to re-send once the timeout limit has been reached. Used by writeFast and writeBlocking to initiate retries when a TX failure occurs. Retries are automatically initiated except with the standard <a class="el" href="classRF24.html#a4cd4c198a47704db20b6b5cf0731cd58">write()</a>. This way, data is not flushed from the buffer until switching between modes.</p>
<dl class="section note"><dt>Note</dt><dd>This is to be used AFTER auto-retry fails if wanting to resend using the built-in payload reuse features. After issuing <a class="el" href="classRF24.html#aeaf7fa54d3ab2a85ce215b4bf6ae933b">reUseTX()</a>, it will keep reending the same payload forever or until a payload is written to the FIFO, or a flush_tx command is given. </dd></dl>

</div>
</div>
<a class="anchor" id="adb7915b1d2661a82137573344f659e81"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t RF24::flush_tx </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Empty the transmit buffer</p>
<dl class="section return"><dt>Returns</dt><dd>Current value of status register </dd></dl>

</div>
</div>
<a class="anchor" id="ad0d522ccf39493510e64bf1740be790d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RF24::testCarrier </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Test whether there was a carrier on the line for the previous listening period.</p>
<p>Useful to check for interference on the current channel.</p>
<dl class="section return"><dt>Returns</dt><dd>true if was carrier, false if not </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="scanner_8ino-example.html#a6">scanner.ino</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a821285f3b54553f4402eb3fd0ac6d6c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RF24::testRPD </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Test whether a signal (carrier or otherwise) greater than or equal to -64dBm is present on the channel. Valid only on nRF24L01P (+) hardware. On nRF24L01, use <a class="el" href="classRF24.html#ad0d522ccf39493510e64bf1740be790d">testCarrier()</a>.</p>
<p>Useful to check for interference on the current channel and channel hopping strategies.</p>
<dl class="section return"><dt>Returns</dt><dd>true if signal =&gt; -64dBm, false if not </dd></dl>

</div>
</div>
<a class="anchor" id="a35e5f1533b7753806c42b76e782d917e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RF24::isValid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Test whether this is a real radio, or a mock shim for debugging. Setting either pin to 0xff is the way to indicate that this is not a real radio.</p>
<dl class="section return"><dt>Returns</dt><dd>true if this is a legitimate radio </dd></dl>

</div>
</div>
<a class="anchor" id="abf68b9b0c9cd17179e9e144c3e7f9c45"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::maskIRQ </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>tx_ok</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>tx_fail</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>rx_ready</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The radio will generate interrupt signals when a transmission is complete, a transmission fails, or a payload is received. This allows users to mask those interrupts to prevent them from generating a signal on the interrupt pin.</p>
<div class="fragment"><div class="line">Mask all interrupts except the receive interrupt:</div>
<div class="line"></div>
<div class="line">radio.<a class="code" href="classRF24.html#abf68b9b0c9cd17179e9e144c3e7f9c45">maskIRQ</a>(1,1,0);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tx_ok</td><td>Mask transmission complete interrupts </td></tr>
    <tr><td class="paramname">tx_fail</td><td>Mask transmit failure interrupts </td></tr>
    <tr><td class="paramname">rx_ready</td><td>Mask payload received interrupts </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad5aea7f9a3bd9c7d357fb296ce751f21"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::setAddressWidth </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>a_width</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the address width from 3 to 5 bytes (24, 32 or 40 bit)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a_width</td><td>The address width to use: 3,4 or 5 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9944d93994a80037e3586f340f5e0107"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::closeReadingPipe </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>pipe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Close a pipe after it has been previously opened. Can be safely called without having previously opened a pipe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pipe</td><td>Which pipe # to close, 0-5. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4c6d3959c8320e64568395f4ef507aef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::setRetries </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>delay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the number and delay of retries upon failed submit</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">delay</td><td>How long to wait between each retry, in multiples of 250us, max is 15. 0 means 250us, 15 means 4000us. </td></tr>
    <tr><td class="paramname">count</td><td>How many retries before giving up, max 15 </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="GettingStarted_8ino-example.html#a3">GettingStarted.ino</a>, <a class="el" href="GettingStarted_CallResponse_8ino-example.html#a5">GettingStarted_CallResponse.ino</a>, <a class="el" href="pingpair_ack_8ino-example.html#a4">pingpair_ack.ino</a>, <a class="el" href="pingpair_dyn_8ino-example.html#a3">pingpair_dyn.ino</a>, <a class="el" href="pingpair_maple_8pde-example.html#a2">pingpair_maple.pde</a>, <a class="el" href="Transfer_8ino-example.html#a6">Transfer.ino</a>, and <a class="el" href="TransferTimeouts_8ino-example.html#a6">TransferTimeouts.ino</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a5e6e5a5f6c85d2638381cab2c0f3702e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::setChannel </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set RF communication channel</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Which RF channel to communicate on, 0-127 </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="nordic_fob_8pde-example.html#a2">nordic_fob.pde</a>, <a class="el" href="scanner_8ino-example.html#a5">scanner.ino</a>, <a class="el" href="Transfer_8ino-example.html#a2">Transfer.ino</a>, and <a class="el" href="TransferTimeouts_8ino-example.html#a2">TransferTimeouts.ino</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a343e5d23477181011dea030fafb1954f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::setPayloadSize </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set Static Payload Size</p>
<p>This implementation uses a pre-stablished fixed payload size for all transmissions. If this method is never called, the driver will always transmit the maximum payload size (32 bytes), no matter how much was sent to <a class="el" href="classRF24.html#a4cd4c198a47704db20b6b5cf0731cd58">write()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The number of bytes in the payload </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="GettingStarted_CallResponse_8ino-example.html#a6">GettingStarted_CallResponse.ino</a>, <a class="el" href="nordic_fob_8pde-example.html#a3">nordic_fob.pde</a>, <a class="el" href="pingpair_ack_8ino-example.html#a5">pingpair_ack.ino</a>, and <a class="el" href="pingpair_maple_8pde-example.html#a3">pingpair_maple.pde</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a0aa0c7cbe3d38fef4722f3f1d2d6c5f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t RF24::getPayloadSize </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get Static Payload Size</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classRF24.html#a343e5d23477181011dea030fafb1954f">setPayloadSize()</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes in the payload </dd></dl>

</div>
</div>
<a class="anchor" id="a65963ed8d8fd45f847e2f673995b85e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t RF24::getDynamicPayloadSize </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get Dynamic Payload Size</p>
<p>For dynamic payloads, this pulls the size of the payload off the chip</p>
<dl class="section note"><dt>Note</dt><dd>Corrupt packets are now detected and flushed per the manufacturer.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Payload length of last-received dynamic payload </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="pingpair_dyn_8ino-example.html#a11">pingpair_dyn.ino</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="abf8efced2ee9edbcc6510878b20edc1b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::enableAckPayload </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable custom payloads on the acknowledge packets</p>
<p>Ack payloads are a handy way to return data back to senders without manually changing the radio modes on both units.</p>
<dl class="section see"><dt>See Also</dt><dd>examples/GettingStarted_CallResponse/GettingStarted_CallResponse.ino </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="GettingStarted_CallResponse_8ino-example.html#a3">GettingStarted_CallResponse.ino</a>, <a class="el" href="pingpair_ack_8ino-example.html#a3">pingpair_ack.ino</a>, and <a class="el" href="pingpair_irq_8ino-example.html#a2">pingpair_irq.ino</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a443888504975d7441d6452a09d09a8fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::enableDynamicPayloads </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable dynamically-sized payloads</p>
<p>This way you don't always have to send large packets just to send them once in a while. This enables dynamic payloads on ALL pipes.</p>
<dl class="section see"><dt>See Also</dt><dd>examples/pingpair_pl/pingpair_dyn.pde </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="pingpair_dyn_8ino-example.html#a2">pingpair_dyn.ino</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a62846750b82682beb7593719eb60ed60"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RF24::isPVariant </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine whether the hardware is an nRF24L01+ or not.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the hardware is nRF24L01+ (or compatible) and false if its not. </dd></dl>

</div>
</div>
<a class="anchor" id="aec71746d59da978bcbb975167886a2cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::setAutoAck </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable or disable auto-acknowlede packets</p>
<p>This is enabled by default, so it's only needed if you want to turn it off for some reason.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>Whether to enable (true) or disable (false) auto-acks </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="GettingStarted_8ino-example.html#a2">GettingStarted.ino</a>, <a class="el" href="GettingStarted_CallResponse_8ino-example.html#a2">GettingStarted_CallResponse.ino</a>, <a class="el" href="nordic_fob_8pde-example.html#a4">nordic_fob.pde</a>, <a class="el" href="pingpair_ack_8ino-example.html#a2">pingpair_ack.ino</a>, <a class="el" href="scanner_8ino-example.html#a2">scanner.ino</a>, <a class="el" href="Transfer_8ino-example.html#a5">Transfer.ino</a>, and <a class="el" href="TransferTimeouts_8ino-example.html#a5">TransferTimeouts.ino</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a60dba9e558f3620ab489af68ea3dea9c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::setAutoAck </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>pipe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable or disable auto-acknowlede packets on a per pipeline basis.</p>
<p>AA is enabled by default, so it's only needed if you want to turn it off/on for some reason on a per pipeline basis.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pipe</td><td>Which pipeline to modify </td></tr>
    <tr><td class="paramname">enable</td><td>Whether to enable (true) or disable (false) auto-acks </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adedac579590a668ae97baccab284de8a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::setPALevel </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set Power Amplifier (PA) level to one of four levels: RF24_PA_MIN, RF24_PA_LOW, RF24_PA_HIGH and RF24_PA_MAX</p>
<p>The power levels correspond to the following output levels respectively: NRF24L01: -18dBm, -12dBm,-6dBM, and 0dBm</p>
<p>SI24R1: -6dBm, 0dBm, 3dBM, and 7dBm.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>Desired PA level. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="Transfer_8ino-example.html#a3">Transfer.ino</a>, and <a class="el" href="TransferTimeouts_8ino-example.html#a3">TransferTimeouts.ino</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="af7c4dcd84466168c5816382ceb366067"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t RF24::getPALevel </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fetches the current PA level.</p>
<p>NRF24L01: -18dBm, -12dBm, -6dBm and 0dBm SI24R1: -6dBm, 0dBm, 3dBm, 7dBm</p>
<dl class="section return"><dt>Returns</dt><dd>Returns values 0 to 3 representing the PA Level. </dd></dl>

</div>
</div>
<a class="anchor" id="aeb9920e7a95699748b003c4a839b0814"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RF24::setDataRate </td>
          <td>(</td>
          <td class="paramtype">rf24_datarate_e&#160;</td>
          <td class="paramname"><em>speed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the transmission data rate</p>
<dl class="section warning"><dt>Warning</dt><dd>setting RF24_250KBPS will fail for non-plus units</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">speed</td><td>RF24_250KBPS for 250kbs, RF24_1MBPS for 1Mbps, or RF24_2MBPS for 2Mbps </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the change was successful </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="Transfer_8ino-example.html#a4">Transfer.ino</a>, and <a class="el" href="TransferTimeouts_8ino-example.html#a4">TransferTimeouts.ino</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a72a7b11dafe8ffab6135f243decce0d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rf24_datarate_e RF24::getDataRate </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fetches the transmission data rate</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the hardware's currently configured datarate. The value is one of 250kbs, RF24_1MBPS for 1Mbps, or RF24_2MBPS, as defined in the rf24_datarate_e enum. </dd></dl>

</div>
</div>
<a class="anchor" id="a89f626fc4a58dd997153bcc0f8198b9e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::setCRCLength </td>
          <td>(</td>
          <td class="paramtype">rf24_crclength_e&#160;</td>
          <td class="paramname"><em>length</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the CRC length</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>RF24_CRC_8 for 8-bit or RF24_CRC_16 for 16-bit </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="nordic_fob_8pde-example.html#a5">nordic_fob.pde</a>, <a class="el" href="Transfer_8ino-example.html#a7">Transfer.ino</a>, and <a class="el" href="TransferTimeouts_8ino-example.html#a7">TransferTimeouts.ino</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="aba4ca91b829afcd94a4c11e0343e3796"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rf24_crclength_e RF24::getCRCLength </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the CRC length</p>
<dl class="section return"><dt>Returns</dt><dd>RF24_DISABLED if disabled or RF24_CRC_8 for 8-bit or RF24_CRC_16 for 16-bit </dd></dl>

</div>
</div>
<a class="anchor" id="a5eacd9ecfbc19864801d714c292cf8be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::disableCRC </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disable CRC validation </p>

</div>
</div>
<a class="anchor" id="aa7e8523f86f9f8f20c274e0c89a5fd45"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::openReadingPipe </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Open a pipe for reading </p>
<dl class="section note"><dt>Note</dt><dd>For compatibility with old code only, see new function</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Pipes 1-5 should share the first 32 bits. Only the least significant byte should be unique, e.g. <div class="fragment"><div class="line"><a class="code" href="classRF24.html#a9edc910ccc1ffcff56814b08faca5535">openReadingPipe</a>(1,0xF0F0F0F0AA);</div>
<div class="line"><a class="code" href="classRF24.html#a9edc910ccc1ffcff56814b08faca5535">openReadingPipe</a>(2,0xF0F0F0F066);</div>
</div><!-- fragment --></dd>
<dd>
Pipe 0 is also used by the writing pipe. So if you open pipe 0 for reading, and then <a class="el" href="classRF24.html#a30a2733a3889bdc331fe2d2f4f0f7b39">startListening()</a>, it will overwrite the writing pipe. Ergo, do an <a class="el" href="classRF24.html#af2e409e62d49a23e372a70b904ae30e1">openWritingPipe()</a> again before <a class="el" href="classRF24.html#a4cd4c198a47704db20b6b5cf0731cd58">write()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">number</td><td>Which pipe# to open, 0-5. </td></tr>
    <tr><td class="paramname">address</td><td>The 40-bit address of the pipe to open. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a50c8e68ee840e1860a31dbdc83afbd77"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF24::openWritingPipe </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Open a pipe for writing </p>
<dl class="section note"><dt>Note</dt><dd>For compatibility with old code only, see new function Addresses are 40-bit hex values, e.g.:</dd></dl>
<div class="fragment"><div class="line"><a class="code" href="classRF24.html#af2e409e62d49a23e372a70b904ae30e1">openWritingPipe</a>(0xF0F0F0F0F0);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>The 40-bit address of the pipe to open. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a2e40fe66d1231a333aa2534e8491f828"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RF24::failureDetected</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable error detection by un-commenting #define FAILURE_HANDLING in <a class="el" href="RF24__config_8h_source.html">RF24_config.h</a> If a failure has been detected, it usually indicates a hardware issue. By default the library will cease operation when a failure is detected. This should allow advanced users to detect and resolve intermittent hardware issues.</p>
<p>In most cases, the radio must be re-enabled via radio.begin(); and the appropriate settings applied after a failure occurs, if wanting to re-enable the device immediately.</p>
<p>Usage: (Failure handling must be enabled per above) </p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span>(radio.<a class="code" href="classRF24.html#a2e40fe66d1231a333aa2534e8491f828">failureDetected</a>){ </div>
<div class="line">  radio.<a class="code" href="classRF24.html#a9e720d303ad594de611a813c69244517">begin</a>();                        <span class="comment">// Attempt to re-configure the radio with defaults</span></div>
<div class="line">  radio.<a class="code" href="classRF24.html#a2e40fe66d1231a333aa2534e8491f828">failureDetected</a> = 0;            <span class="comment">// Reset the detection value</span></div>
<div class="line">  radio.<a class="code" href="classRF24.html#af2e409e62d49a23e372a70b904ae30e1">openWritingPipe</a>(addresses[1]); <span class="comment">// Re-configure pipe addresses</span></div>
<div class="line">  radio.<a class="code" href="classRF24.html#a9edc910ccc1ffcff56814b08faca5535">openReadingPipe</a>(1,addresses[0]);</div>
<div class="line">  report_failure();                 <span class="comment">// Blink leds, send a message, etc. to indicate failure</span></div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Aug 4 2014 16:08:46 for Optimized High Speed NRF24L01+ Driver Class Documenation by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
